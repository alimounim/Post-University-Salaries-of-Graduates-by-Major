# -*- coding: utf-8 -*-
"""Post-University Salaries of Graduates by Major.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OjvpJ8VV5ZRwAQjlD30cG2rHo8iUmVQc
"""

import pandas as pd
df = pd.read_csv('/content/sample_data/salaries_by_college_major.csv')
pd.options.display.float_format = '{:,.2f}'.format
df.head()

"""How many rows does our dataframe have?

How many columns does it have?

What are the labels for the columns? Do the columns have names?

Are there any missing values in our dataframe? Does our dataframe contain any bad data?
"""

print(f"Number of rows: {df.shape[0]}")
print(f"Number of columns: {df.shape[1]}")
print("Column names:")
for col in df.columns:
    print(f"- {col}")
# finding the rows with NaN value.
df[df.isna().any(axis=1)]

# Deleting the NaN rows
clean_df = df.dropna()
clean_df.tail()

"""1. Find College Major with Highest Starting Salaries"""

index_highest_salary_major = clean_df['Starting Median Salary'].idxmax()
highest_salary_major = clean_df['Undergraduate Major'].loc[index_highest_salary_major]
print(f"The college major with the highest starting salary is: {highest_salary_major}")

"""2. What college major has the highest mid-career salary? How much do graduates with this major earn? (Mid-career is defined as having 10+ years of experience)."""

index_highest_mid_career_salary_major = clean_df['Mid-Career Median Salary'].idxmax()
highest_mid_career_salary_major = clean_df['Undergraduate Major'].loc[index_highest_mid_career_salary_major]
print(f"The college major with the highest mid-career salary is: {highest_mid_career_salary_major}")

"""3. Which college major has the lowest starting salary and how much do graduates earn after university?"""

index_lowest_starting_salary_major = clean_df['Starting Median Salary'].idxmin()
lowest_starting_salary_major = clean_df['Undergraduate Major'].loc[index_lowest_starting_salary_major]
print(f"The college major with the lowest starting salary is: {lowest_starting_salary_major}")

"""4. Which college major has the lowest mid-career salary and how much can people expect to earn with this degree?"""

index_lowest_mid_career_salary_major = clean_df['Mid-Career Median Salary'].idxmin()
lowest_mid_career_salary_major = clean_df['Undergraduate Major'].loc[index_lowest_mid_career_salary_major]
print(f"The college major with the lowest mid-career salary is: {lowest_mid_career_salary_major}")

"""# Lowest Risk Majors
A low-risk major is a degree where there is a small difference between the lowest and highest salaries. In other words, if the difference between the 10th percentile and the 90th percentile earnings of your major is small, then you can be more certain about your salary after you graduate.
"""

spread_col = clean_df['Mid-Career 90th Percentile Salary'] - clean_df['Mid-Career 10th Percentile Salary']
clean_df.insert(1, 'Spread', spread_col)
clean_df.head()

low_risk = clean_df.sort_values('Spread')
print(f"The top 5 lowest risk majors are: {low_risk[['Undergraduate Major', 'Spread']].head()}")

"""Degrees with the highest potential:

Find the top 5 degrees with the highest values in the 90th percentile.
"""

degrees_with_highest_potential = clean_df.sort_values('Mid-Career 90th Percentile Salary', ascending=False).head(5)
print(f"The top 5 degrees with the highest values in the 90th percentile are: {degrees_with_highest_potential[['Undergraduate Major', 'Mid-Career 90th Percentile Salary']]}")

""" Degrees with the greatest spread in salaries.

 Which majors have the largest difference between high and low earners after graduation.
"""

highest_spread = clean_df.sort_values('Spread', ascending=False)
print(f"The top 5 majors with the largest difference between high and low earners after graduation are: {highest_spread[['Undergraduate Major', 'Spread']].head()}")
#

"""How many majors we have in each category?"""

clean_df.groupby('Group').count()

"""There are:

12 majors in Business category.

22 majors in HASS category.


16 majors in STEM category.

Find the average salary by group?
"""

clean_df.groupby('Group').mean(numeric_only=True)